-- paths to metamodels for content assist
--@path HAL=/HAL/model/hal.ecore
--@path URN=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

module Hal2Urn;
create OUT : URN from IN : HAL;

-- HAL to URN
rule hal2urn {
	from 
		h : HAL!HAL
	to 
		u : URN!URNspec (
				
		),
		d: URN!URNdefinition (
			urnspec <- u
		)
	do {
		thisModule.HAL <- h;
	}
}
	
helper def : previous : URN!IURNNode = '';
helper def : lhs : URN!IURNNode = '';
helper def : rhs : URN!IURNNode = '';
--helper def : crts : Sequence(URN!IURNNode) = '';

helper def : ConnectionsDown(ar: HAL!AutomationRule, prev : URN!IURNNode, curr : URN!IURNNode, container : URL!UCMmap) : URN!IURNNode = 
	if curr.LHS.oclIsTypeOf(HAL!CompoundRelationalTerm) then
		thisModule.ConnectionsDown(ar, prev, curr.LHS, container)
	else
		--curr
		thisModule.BackUp(ar, curr.LHS, curr.RHS, container)
	endif
	;

helper def : BackUp(ar: HAL!AutomationRule, prev : URN!IURNNode, curr : URN!IURNNode, container : URL!UCMmap) : URN!IURNNode = 
	if prev.oclIsTypeOf(HAL!AtomicRelationalTerm) and curr.oclIsTypeOf(HAL!AtomicRelationalTerm) then
		thisModule.previous = thisModule.BackUp(ar, thisModule.NewConnection(prev, curr, container), curr.eContainer(), container)
	else
		thisModule.BackUp(ar, thisModule.previous, curr, container)
	endif
	;
	
helper def : ConnectionsUp(ar: HAL!AutomationRule, prev : URN!IURNNode, curr : URN!IURNNode, container : URL!UCMmap) : URN!IURNNode = 
	if curr.eContainer().oclIsTypeOf(HAL!AutomationRule) then
		curr.eContainer().oclType().debug()
	else 
		'up: not an automation rule'.debug()
		--if curr.eContainer().RHS.oclIsTypeOf(HAL!CompoundRelationalTerm) then
	endif
	;


-- AutomationRule to UCMmap
rule AutomationRule2UCMmap {
	from
		ar: HAL!AutomationRule
	to
		-- UCMmap
		um: URN!UCMmap (
			name <- ar.name,
			urndefinition <- thisModule.resolveTemp(ar.eContainer(), 'd')
		),
		-- StartPoint
		sp: URN!StartPoint (
			name <- 'checkRule',
			diagram <- um
		),
		-- EndPoint
		epTriggered: URN!EndPoint (
			name <- 'ruleTriggered',
			diagram <- um
		),
		epNotTriggered: URN!EndPoint (
			name <- 'ruleNotTriggered',
			diagram <- um
		),
		-- Labels
		label4StartPoint: URN!NodeLabel (
			node <- sp
		),
		label4epTriggered: URN!NodeLabel (
			node <- epTriggered
		),
		label4epNotTriggered: URN!NodeLabel (
			node <- epNotTriggered
		)
		
	do {	
		
		-- Connections
		thisModule.previous <- sp;
		thisModule.curr;
		
		-- Downwards
		thisModule.curr <- thisModule.ConnectionsDown(ar, thisModule.previous, ar.precondition, um);
		--thisModule.NewConnection(sp, thisModule.curr.LHS, um);
		--thisModule.curr.LHS.oclType().debug();
		--thisModule.previous <- thisModule.curr.LHS;
		--thisModule.NewConnection(thisModule.previous, thisModule.resolveTemp(thisModule.curr.RHS, 'st'), um);
			
		-- Upwards
		-- thisModule.curr.LHS.eContainer().oclType().debug();
		--thisModule.ConnectionsUp(ar, thisModule.previous, thisModule.curr, um);
		
		
			
	
	}
}


-- Command to Responsibility
rule Command2Responsibility {
	from 
		com: HAL!Command
	to
		res: URN!Responsibility (
				name <- com.name,
				urndefinition <- thisModule.resolveTemp(thisModule.HAL, 'd')
			)
}

-- Actions to ComponentRef
rule Action2ComponentRef {
	from 
		action: HAL!Action
	to
		respRef: URN!RespRef (
			diagram <- thisModule.resolveTemp(action.eContainer(), 'um'),
			respDef <- thisModule.resolveTemp(action.command, 'res'),
			contRef <- compRef
		),
		compRef: URN!ComponentRef (
			diagram <- thisModule.resolveTemp(action.eContainer(), 'um'),
			contDef <- thisModule.resolveTemp(action.actuator, 'comp'),
			nodes <- respRef,
			width <- 300,
			height <- 100
		),
		label4respRef: URN!NodeLabel (
			node <- respRef	
		),
		label4compRef: URN!ComponentLabel (
			contRef <- compRef	
		)

		
}

-- Device to Component
rule Device2Component {
	from
		dev: HAL!Device
	to
		comp: URN!Component (
			name <- dev.eContainer().name + '.' + dev.name,
			urndefinition <- thisModule.resolveTemp(thisModule.HAL, 'd')
		)
}


-- CompoundRelationalTerm to OrJoin
rule CompoundRelationalTerm2OrJoin {
	from
		crt: HAL!CompoundRelationalTerm
	to
		oj: URN!OrJoin (
			diagram <- thisModule.resolveTemp(crt.eContainer(), 'um')
		)
	do {
		
		
	}
}

-- AtomicRelationalTerm to Stub
rule AtomicRelationalTerm2Stub {
	from
		art: HAL!AtomicRelationalTerm
	to
		st: URN!Stub (
			diagram <- thisModule.resolveTemp(art.eContainer().eContainer(), 'um')
		),
		label4Stub: URN!NodeLabel (
			node <- st		
		)
	do {
		
		if(art.negated = true) {
			st.name <- 'NOT (' + art.sensor.name + ' IN ' + art.sensor.eContainer().name + ' ' + art.operator + ' ' + art.comparedAgainstValue + ')';	
		} else {
			st.name <- art.sensor.name + ' IN ' + art.sensor.eContainer().name + ' ' + art.operator + ' ' + art.comparedAgainstValue;	
		}
		st;
		
	}
}


-- Create connections helper method
rule NewConnection(source : URN!IURNNode, target : URN!IURNNode, container : URN!UCMmap) {
	to
		connection: URN!NodeConnection (
				source <- source,
				target <- target,
				diagram <- container
			)
	do {
		'new connection created'.debug();	
		target;
	}
		
}












