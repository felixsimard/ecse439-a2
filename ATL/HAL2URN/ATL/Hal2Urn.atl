-- paths to metamodels for content assist
--@path HAL=/HAL/model/hal.ecore
--@path URN=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

module Hal2Urn;
create OUT : URN from IN : HAL;

-- HAL to URN
rule hal2urn {
	from 
		h : HAL!HAL
	to 
		u : URN!URNspec (
				
		),
		d: URN!URNdefinition (
			urnspec <- u
		)
	do {
		thisModule.HAL <- h;
	}
}
	
helper def : previous : URN!IURNNode = '';
helper def : lhs : URN!IURNNode = '';
helper def : rhs : URN!IURNNode = '';
--helper def : crts : Sequence(URN!IURNNode) = '';

helper def : ConnectionsDown(ar: HAL!AutomationRule, prev : URN!IURNNode, curr : URN!IURNNode, container : URL!UCMmap) : URN!IURNNode = 
	if curr.LHS.oclIsTypeOf(HAL!CompoundRelationalTerm) then
		thisModule.ConnectionsDown(ar, prev, curr.LHS, container)
	else
		--curr
		thisModule.BackUp(ar, curr.LHS, curr.RHS, container)
	endif
	;

helper def : BackUp(ar: HAL!AutomationRule, prev : URN!IURNNode, curr : URN!IURNNode, container : URL!UCMmap) : URN!IURNNode = 
	if prev.oclIsTypeOf(HAL!AtomicRelationalTerm) and curr.oclIsTypeOf(HAL!AtomicRelationalTerm) then
		thisModule.previous = thisModule.BackUp(ar, thisModule.NewConnection(prev, curr, container), curr.eContainer(), container)
	else 
		thisModule.BackUp(ar, thisModule.previous, curr, container)
	endif
	;
	
helper def : ConnectionsUp(ar: HAL!AutomationRule, prev : URN!IURNNode, curr : URN!IURNNode, container : URL!UCMmap) : URN!IURNNode = 
	if curr.eContainer().oclIsTypeOf(HAL!AutomationRule) then
		curr.eContainer().oclType().debug()
	else 
		'up: not an automation rule'.debug()
		--if curr.eContainer().RHS.oclIsTypeOf(HAL!CompoundRelationalTerm) then
	endif
	;


rule searchTree(node: URN!IURNNode, parent: URN!IURNNode, notTriggered: URN!IURNNode, container : URL!UCMmap, isLeft: Boolean) {
	do {
		if (node.oclIsTypeOf(HAL!AtomicRelationalTerm)) {
			thisModule.NewConnection(thisModule.previous, thisModule.resolveTemp(node, 'st'), container);
			thisModule.previous <- thisModule.resolveTemp(node, 'st');
			if (parent.oclIsTypeOf(HAL!CompoundRelationalTerm)) {
				if (parent.operator = #AND) {
					thisModule.resolveTemp(parent, 'oj').oclIsTypeOf(URN!OrJoin).debug();
					thisModule.NewConnection(thisModule.resolveTemp(node, 'st'), thisModule.resolveTemp(parent, 'oj'), container);
					if (isLeft = true or (parent.LHS.oclIsTypeOf(HAL!CompoundRelationalTerm) and parent.RHS.oclIsTypeOf(HAL!AtomicRelationalTerm))) {
						'here4'.debug();
						thisModule.lastOJ.debug();
						if (thisModule.lastOJ = OclUndefined) {
						} else {
							thisModule.NewConnection(thisModule.lastOJ, thisModule.resolveTemp(parent, 'oj'), container);
						}
						thisModule.lastOJ <- thisModule.resolveTemp(parent, 'oj');
					}
				} else {
					if (isLeft = false) {
						'hihellohere'.debug();
						thisModule.previous <- thisModule.resolveTemp(parent, 'oj');
						thisModule.lastOJ <- node;
						--if (thisModule.lastOJ.oclIsTypeOf(URN!OrJoin)) {
							--'gothere123'.debug();
							--thisModule.NewConnection(thisModule.resolveTemp(node, 'st'), thisModule.lastOJ, container);
						--}
					}
					thisModule.NewConnection(thisModule.resolveTemp(node, 'st'), thisModule.resolveTemp(parent, 'oj'), container);
				}
				
			}
			else{
				thisModule.NewConnection(thisModule.resolveTemp(node, 'st'), notTriggered, container);
			}
		}
		else if (node.oclIsTypeOf(HAL!CompoundRelationalTerm)) {
			thisModule.searchTree(node.LHS, node, notTriggered, container, true);
			thisModule.searchTree(node.RHS, node, notTriggered, container, false);
			--thisModule.lastOJ <- thisModule.resolveTemp(node, 'oj');
		}
	}
}

-- AutomationRule to UCMmap
rule AutomationRule2UCMmap {
	from
		ar: HAL!AutomationRule
	to
		-- UCMmap
		um: URN!UCMmap (
			name <- ar.name,
			urndefinition <- thisModule.resolveTemp(ar.eContainer(), 'd')
		),
		-- StartPoint
		sp: URN!StartPoint (
			name <- 'checkRule',
			diagram <- um
		),
		-- EndPoint
		epTriggered: URN!EndPoint (
			name <- 'ruleTriggered',
			diagram <- um
		),
		epNotTriggered: URN!EndPoint (
			name <- 'ruleNotTriggered',
			diagram <- um
		),
		-- Labels
		label4StartPoint: URN!NodeLabel (
			node <- sp
		),
		label4epTriggered: URN!NodeLabel (
			node <- epTriggered
		),
		label4epNotTriggered: URN!NodeLabel (
			node <- epNotTriggered
		)
		
	do {	
		
		-- Connections
		thisModule.previous <- sp;
		-- thisModule.curr;
		
		-- Downwards
		-- thisModule.curr <- thisModule.ConnectionsDown(ar, thisModule.previous, ar.precondition, um);
		--thisModule.NewConnection(sp, thisModule.curr.LHS, um);
		--thisModule.curr.LHS.oclType().debug();
		--thisModule.previous <- thisModule.curr.LHS;
		--thisModule.NewConnection(thisModule.previous, thisModule.resolveTemp(thisModule.curr.RHS, 'st'), um);
			
		-- Upwards
		-- thisModule.curr.LHS.eContainer().oclType().debug();
		--thisModule.ConnectionsUp(ar, thisModule.previous, thisModule.curr, um);
		thisModule.lastOJ <- OclUndefined;
		'NEWSEARCH'.debug();
		thisModule.searchTree(ar.precondition, '', epNotTriggered, um, false);
		
		if (thisModule.lastOJ = OclUndefined) {
			
		} else {
			thisModule.NewConnection(thisModule.lastOJ, epNotTriggered, um);
		}
		for (a in HAL!Action.allInstances()) {
			if (a.eContainer() = ar) {
				thisModule.NewConnection(thisModule.previous, thisModule.resolveTemp(a, 'respRef'), um);
				thisModule.previous <- thisModule.resolveTemp(a, 'respRef');
			}
		}
		
		thisModule.NewConnection(thisModule.previous, epTriggered, um);
	
	}
}


-- Command to Responsibility
rule Command2Responsibility {
	from 
		com: HAL!Command
	to
		res: URN!Responsibility (
				name <- com.name,
				urndefinition <- thisModule.resolveTemp(thisModule.HAL, 'd')
			)
}

-- Actions to ComponentRef
rule Action2ComponentRef {
	from 
		action: HAL!Action
	to
		respRef: URN!RespRef (
			diagram <- thisModule.resolveTemp(action.eContainer(), 'um'),
			respDef <- thisModule.resolveTemp(action.command, 'res'),
			contRef <- compRef
		),
		compRef: URN!ComponentRef (
			diagram <- thisModule.resolveTemp(action.eContainer(), 'um'),
			contDef <- thisModule.resolveTemp(action.actuator, 'comp'),
			nodes <- respRef,
			width <- 300,
			height <- 100
		),
		label4respRef: URN!NodeLabel (
			node <- respRef	
		),
		label4compRef: URN!ComponentLabel (
			contRef <- compRef	
		)

		
}

-- Device to Component
rule Device2Component {
	from
		dev: HAL!Device
	to
		comp: URN!Component (
			name <- dev.eContainer().name + '.' + dev.name,
			urndefinition <- thisModule.resolveTemp(thisModule.HAL, 'd')
		)
}


-- CompoundRelationalTerm to OrJoin
rule CompoundRelationalTerm2OrJoin {
	from
		crt: HAL!CompoundRelationalTerm
	to
		oj: URN!OrJoin (
			diagram <- thisModule.resolveTemp(crt.eContainer(), 'um')
		)
	do {
		if (thisModule.resolveTemp(crt.eContainer(), 'um') = OclUndefined) {
			oj.diagram <- thisModule.resolveTemp(crt.eContainer().eContainer(), 'um');
		}		
	}
}

-- AtomicRelationalTerm to Stub
rule AtomicRelationalTerm2Stub {
	from
		art: HAL!AtomicRelationalTerm
	to
		st: URN!Stub (
			diagram <- thisModule.resolveTemp(art.eContainer().eContainer(), 'um')
		),
		label4Stub: URN!NodeLabel (
			node <- st		
		)
	do {
		thisModule.resolveTemp(thisModule.getContainer(art), 'um').debug();
		st.diagram <- thisModule.resolveTemp(thisModule.getContainer(art), 'um');
		
		if(art.negated = true) {
			st.name <- 'NOT (' + art.sensor.name + ' IN ' + art.sensor.eContainer().name + ' ' + art.operator + ' ' + art.comparedAgainstValue + ')';	
		} else {
			st.name <- art.sensor.name + ' IN ' + art.sensor.eContainer().name + ' ' + art.operator + ' ' + art.comparedAgainstValue;	
		}
		st;
		
	}
}

helper def : getContainer(current: HAL!BooleanExpression) : HAL!AutomationRule = 
	if current.oclIsTypeOf(HAL!AutomationRule)
	then 
		current
	else
		thisModule.getContainer(current.eContainer())
	endif;
	


-- Create connections helper method
rule NewConnection(source : URN!IURNNode, target : URN!IURNNode, container : URN!UCMmap) {
	to
		connection: URN!NodeConnection (
				source <- source,
				target <- target,
				diagram <- container
			)
	do {
		target;
	}
		
}












