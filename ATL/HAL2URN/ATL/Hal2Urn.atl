-- paths to metamodels for content assist
--@path HAL=/HAL/model/hal.ecore
--@path URN=/seg.jUCMNav/src/seg/jUCMNav/emf/urn.ecore

module Hal2Urn;
create OUT : URN from IN : HAL;

-- HAL to URN
rule hal2urn {
	from 
		h : HAL!HAL
	to 
		u : URN!URNspec (
				
		),
		d: URN!URNdefinition (
			urnspec <- u
		)
	do {
		thisModule.HAL <- h;
	}
}
	
helper def : previous : URN!IURNNode = '';
helper def : lhs : URN!IURNNode = '';
helper def : rhs : URN!IURNNode = '';
helper def : trueOut : URN!IURNNode = '';
helper def : falseOut : URN!IURNNode = '';
helper def : inElem : URN!IURNNode = '';


rule searchTree(node: URN!IURNNode, parent: URN!IURNNode, notTriggered: URN!IURNNode, container : URL!UCMmap, isLeft: Boolean) {
	do {
		if (node.oclIsTypeOf(HAL!AtomicRelationalTerm)) {
			if (thisModule.trueOut.oclIsTypeOf(URN!StartPoint)) {
				thisModule.NewConnection(thisModule.trueOut, thisModule.resolveTemp(node, 'st'), container);
			}
			-- 3 1 in, 2 out helpers
			-- set the helpers +

			thisModule.trueOut <- thisModule.resolveTemp(node, 'da');
			thisModule.NewConnection(thisModule.resolveTemp(node, 'st'), thisModule.resolveTemp(node, 'da'), container);
			thisModule.inElem <- thisModule.resolveTemp(node, 'st');
			thisModule.falseOut <- thisModule.resolveTemp(node, 'st');
				
			--thisModule.NewConnection(thisModule.previous, thisModule.falseOut, container);
			--thisModule.NewConnection(thisModule.previous, thisModule.inElem, container);
			--thisModule.NewConnection(thisModule.previous, thisModule.resolveTemp(node, 'st'), container);
			
			-- thisModule.NewConnection(thisModule.previous, thisModule.resolveTemp(node, 'oj'));
			--thisModule.previous <- thisModule.resolveTemp(node, 'st');

		}
		else if (node.oclIsTypeOf(HAL!CompoundRelationalTerm)) {
			thisModule.searchTree(node.LHS, node, notTriggered, container, true);
			-- lhs helpers set
			thisModule.lhstrue <- thisModule.trueOut;
			thisModule.lhsin <- thisModule.inElem;
			thisModule.lhsfalse <- thisModule.falseOut;
			
			thisModule.searchTree(node.RHS, node, notTriggered, container, false);
			-- rhs helpers set
			thisModule.rhstrue <- thisModule.trueOut;
			thisModule.rhsin <- thisModule.inElem;
			thisModule.rhsfalse <- thisModule.falseOut;
			
			--or / and logic
			if(node.operator = #AND) {
				--thisModule.NewConnection(thisModule.NextTrueOut, thisModule.lhsin, container);
				
				thisModule.NewConnection(thisModule.lhsfalse, thisModule.resolveTemp(node, 'oj'), container);
				thisModule.NewConnection(thisModule.lhstrue, thisModule.rhsin, container);
				thisModule.NewConnection(thisModule.rhsfalse, thisModule.resolveTemp(node, 'oj'), container);
				
				thisModule.NextFalseOut <- thisModule.resolveTemp(node, 'oj');
				thisModule.NextTrueOut <- thisModule.rhstrue;
				-- set new in and outs
			}
			if (node.operator = #OR) {
				--thisModule.NewConnection(thisModule.NextTrueOut, thisModule.lhsin, container);
				--thisModule.NewConnection(thisModule.NextFalseOut, thisModule.rhsfalse, container);
				thisModule.NewConnection(thisModule.lhstrue, thisModule.resolveTemp(node, 'oj'), container);
				thisModule.NewConnection(thisModule.rhstrue, thisModule.resolveTemp(node, 'oj'), container);
				thisModule.NewConnection(thisModule.lhsfalse, thisModule.rhsin, container);
				
				thisModule.NextTrueOut <- thisModule.resolveTemp(node, 'oj');
				thisModule.NextFalseOut <- thisModule.rhsfalse;
			}
			
		
	
		}
	}
}

-- Create a direction arrow
rule NewDirectionArrow(container : URN!UCMmap) {
	to
		da: URN!DirectionArrow (
			diagram <- container	
		)
	do {
		da;	
	}
}

-- AutomationRule to UCMmap
rule AutomationRule2UCMmap {
	from
		ar: HAL!AutomationRule
	to
		-- UCMmap
		um: URN!UCMmap (
			name <- ar.name,
			urndefinition <- thisModule.resolveTemp(ar.eContainer(), 'd')
		),
		-- StartPoint
		sp: URN!StartPoint (
			name <- 'checkRule',
			diagram <- um
		),
		-- EndPoint
		epTriggered: URN!EndPoint (
			name <- 'ruleTriggered',
			diagram <- um
		),
		epNotTriggered: URN!EndPoint (
			name <- 'ruleNotTriggered',
			diagram <- um
		),
		-- Labels
		label4StartPoint: URN!NodeLabel (
			node <- sp
		),
		label4epTriggered: URN!NodeLabel (
			node <- epTriggered
		),
		label4epNotTriggered: URN!NodeLabel (
			node <- epNotTriggered
		)
		
	do {	
		
		-- Connections
		thisModule.previous <- sp;
		
		thisModule.trueOut <- sp;
		thisModule.NextTrueOut <- OclUndefined;
		thisModule.NextFalseOut <- OclUndefined;
		-- thisModule.curr;
		
		-- Downwards
		-- thisModule.curr <- thisModule.ConnectionsDown(ar, thisModule.previous, ar.precondition, um);
		--thisModule.NewConnection(sp, thisModule.curr.LHS, um);
		--thisModule.curr.LHS.oclType().debug();
		--thisModule.previous <- thisModule.curr.LHS;
		--thisModule.NewConnection(thisModule.previous, thisModule.resolveTemp(thisModule.curr.RHS, 'st'), um);
			
		-- Upwards
		-- thisModule.curr.LHS.eContainer().oclType().debug();
		--thisModule.ConnectionsUp(ar, thisModule.previous, thisModule.curr, um);
		
		thisModule.searchTree(ar.precondition, '', epNotTriggered, um, false);
		
		if (thisModule.NextFalseOut = OclUndefined) {
			thisModule.NewConnection(thisModule.falseOut, epNotTriggered, um);
		} else {
			thisModule.NewConnection(thisModule.NextFalseOut, epNotTriggered, um);
		}
		
		--thisModule.NewConnection(thisModule.previous, thisModule.trueOut, um);
		--thisModule.previous <- thisModule.trueOut;
		for (a in HAL!Action.allInstances()) {
			if (a.eContainer() = ar) {
				thisModule.NewConnection(thisModule.trueOut, thisModule.resolveTemp(a, 'respRef'), um);
				thisModule.trueOut <- thisModule.resolveTemp(a, 'respRef');
			}
		}
		
		thisModule.NewConnection(thisModule.trueOut, epTriggered, um);
	
	}
}


-- Command to Responsibility
rule Command2Responsibility {
	from 
		com: HAL!Command
	to
		res: URN!Responsibility (
				name <- com.name,
				urndefinition <- thisModule.resolveTemp(thisModule.HAL, 'd')
			)
}

-- Actions to ComponentRef
rule Action2ComponentRef {
	from 
		action: HAL!Action
	to
		respRef: URN!RespRef (
			diagram <- thisModule.resolveTemp(action.eContainer(), 'um'),
			respDef <- thisModule.resolveTemp(action.command, 'res'),
			contRef <- compRef
		),
		compRef: URN!ComponentRef (
			diagram <- thisModule.resolveTemp(action.eContainer(), 'um'),
			contDef <- thisModule.resolveTemp(action.actuator, 'comp'),
			nodes <- respRef,
			width <- 300,
			height <- 100
		),
		label4respRef: URN!NodeLabel (
			node <- respRef	
		),
		label4compRef: URN!ComponentLabel (
			contRef <- compRef	
		)

		
}

-- Device to Component
rule Device2Component {
	from
		dev: HAL!Device
	to
		comp: URN!Component (
			name <- dev.eContainer().name + '.' + dev.name,
			urndefinition <- thisModule.resolveTemp(thisModule.HAL, 'd')
		)
}


-- CompoundRelationalTerm to OrJoin
rule CompoundRelationalTerm2OrJoin {
	from
		crt: HAL!CompoundRelationalTerm
	to
		oj: URN!OrJoin (
			diagram <- thisModule.resolveTemp(crt.eContainer(), 'um')
		)
	do {
		oj.diagram <- thisModule.resolveTemp(thisModule.getContainer(crt), 'um');	
	}
}

-- AtomicRelationalTerm to Stub
rule AtomicRelationalTerm2Stub {
	from
		art: HAL!AtomicRelationalTerm
	to
		st: URN!Stub (
			-- diagram being set in the do block
		),
		label4Stub: URN!NodeLabel (
			node <- st		
		),
		da: URN!DirectionArrow (
			-- diagram being set in the do block
		)
	do {
		st.diagram <- thisModule.resolveTemp(thisModule.getContainer(art), 'um');
		da.diagram <- thisModule.resolveTemp(thisModule.getContainer(art), 'um');
		
		if(art.negated = true) {
			st.name <- 'NOT (' + art.sensor.name + ' IN ' + art.sensor.eContainer().name + ' ' + art.operator + ' ' + art.comparedAgainstValue + ')';	
		} else {
			st.name <- art.sensor.name + ' IN ' + art.sensor.eContainer().name + ' ' + art.operator + ' ' + art.comparedAgainstValue;	
		}
		st;
		
	}
}

helper def : getContainer(current: HAL!BooleanExpression) : HAL!AutomationRule = 
	if current.oclIsTypeOf(HAL!AutomationRule)
	then 
		current
	else
		thisModule.getContainer(current.eContainer())
	endif;
	


-- Create connections helper method
rule NewConnection(source : URN!IURNNode, target : URN!IURNNode, container : URN!UCMmap) {
	to
		connection: URN!NodeConnection (
				source <- source,
				target <- target,
				diagram <- container
			)
	do {
		target;
	}
		
}











